(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{731:function(e,r,v){"use strict";v.r(r);var t=v(15),_=Object(t.a)({},(function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_1-vue3-0有什么更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue3-0有什么更新"}},[e._v("#")]),e._v(" 1.Vue3.0有什么更新")]),e._v(" "),v("p",[e._v("(1) 监测机制的改变")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。\nProxy 和 Object.defineProperty 都是 JavaScript 中用来控制对象行为的工具，但 Proxy 相比于 Object.defineProperty 有以下几个优势：")]),e._v(" "),v("p",[e._v("拦截更多的操作：Object.defineProperty 只能拦截属性的读取和设置操作，而 Proxy 可以拦截对象的许多操作，包括属性查询、删除、枚举等。")]),e._v(" "),v("p",[e._v("更好的数组支持：当你使用 Object.defineProperty 来监听数组时，你需要对数组的每个索引进行定义。而 Proxy 可以直接拦截数组的变化，使得监听数组变得更加方便。")]),e._v(" "),v("p",[e._v("原型链：Object.defineProperty 只能监听对象本身的属性，而无法监听对象原型链上的属性。而 Proxy 可以直接监听原型链上的属性。")]),e._v(" "),v("p",[e._v("不需要预设属性：Object.defineProperty 需要预先知道需要监听的属性，对于未知的属性无法进行监听。而 Proxy 可以在新属性被创建的时候进行拦截。")]),e._v(" "),v("p",[e._v("总的来说，Proxy 提供了更为强大和灵活的对象操作拦截能力，使得我们可以更加方便地对对象进行控制。然而，Proxy 的兼容性不如 Object.defineProperty，在某些旧的浏览器环境下可能无法使用。")])]),e._v(" "),v("li",[v("p",[e._v("消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：")])])]),e._v(" "),v("p",[e._v("(2) 只能监测属性，不能监测对象")]),e._v(" "),v("ul",[v("li",[e._v("检测属性的添加和删除；")]),e._v(" "),v("li",[e._v("检测数组索引和长度的变更；")]),e._v(" "),v("li",[e._v("支持 Map、Set、WeakMap 和 WeakSet。")])]),e._v(" "),v("p",[e._v("(3) 模板")]),e._v(" "),v("ul",[v("li",[e._v("作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。")]),e._v(" "),v("li",[e._v("同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。")])]),e._v(" "),v("p",[e._v("(4) 对象式的组件声明方式")]),e._v(" "),v("ul",[v("li",[e._v("vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。")]),e._v(" "),v("li",[e._v("3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易")])]),e._v(" "),v("p",[e._v("(5) 其它方面的更改")]),e._v(" "),v("ul",[v("li",[e._v("支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。")]),e._v(" "),v("li",[e._v("支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。")]),e._v(" "),v("li",[e._v("基于 tree shaking 优化，提供了更多的内置功能。")])]),e._v(" "),v("p",[e._v("(6)Vue.js 3 使用 Proxy 来替代 Vue.js 2 中的 Object.defineProperty 进行数据的响应式处理，主要有以下几点优势：")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("性能优化")]),e._v("：使用 Proxy 不需要像 Object.defineProperty 那样遍历对象的每个属性进行递归操作，所以在处理大量属性或大型对象时，Proxy 有更好的性能和内存消耗。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("支持全部数据类型")]),e._v("：Object.defineProperty 只能对对象的属性进行劫持，所以无法监听到数组下标的变化，也不能对 Map、Set、Symbol 等新的数据类型进行响应式处理。而 Proxy 可以劫持整个对象，并以非侵入的方式处理对象的所有操作。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("更多的拦截操作")]),e._v("：Proxy 可以拦截更多的操作，如新增属性、删除属性等，不仅仅是修改属性值。Object.defineProperty 只能监听属性值的修改。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("原型链代理")]),e._v("：Proxy 可以直接代理原型链。")])])]),e._v(" "),v("p",[e._v("基于以上原因，Vue 3 使用 Proxy 实现数据的响应式比 Vue 2 中的 Object.defineProperty 性能更好，且功能更强大。不过，需要注意的是 Proxy 的兼容性并不好，不能在 IE 中使用，所以 Vue 3 仍然提供了 Vue 2 风格的 API 来兼容老的浏览器。")])])}),[],!1,null,null,null);r.default=_.exports}}]);