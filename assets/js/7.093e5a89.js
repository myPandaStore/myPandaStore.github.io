(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{614:function(_,v,t){_.exports=t.p+"assets/img/014.4ca9e925.png"},615:function(_,v,t){_.exports=t.p+"assets/img/015.05d2f164.png"},616:function(_,v,t){_.exports=t.p+"assets/img/016.1d9e8147.jpg"},617:function(_,v,t){_.exports=t.p+"assets/img/018.438366a2.jpg"},618:function(_,v,t){_.exports=t.p+"assets/img/017.c574e054.jpg"},619:function(_,v,t){_.exports=t.p+"assets/img/019.90585c97.png"},620:function(_,v,t){_.exports=t.p+"assets/img/020.76254e50.png"},710:function(_,v,t){"use strict";t.r(v);var s=t(15),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h2",{attrs:{id:"_1-tcp的拥塞控制机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp的拥塞控制机制"}},[_._v("#")]),_._v(" 1.TCP的拥塞控制机制")]),_._v(" "),s("p",[_._v("拥塞控制是为了在网络条件不佳时，合理地控制发送方的发送速率，以避免网络阻塞")]),_._v(" "),s("p",[_._v("TCP的拥塞控制机制主要是以下四种机制：")]),_._v(" "),s("ol",[s("li",[_._v("慢启动（慢开始）")])]),_._v(" "),s("ul",[s("li",[_._v("在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）")]),_._v(" "),s("li",[_._v("思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。")]),_._v(" "),s("li",[_._v("为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)\n"),s("ul",[s("li",[_._v("当cnwd < ssthresh，使用慢开始算法")]),_._v(" "),s("li",[_._v("当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法")]),_._v(" "),s("li",[_._v("当cnwd > ssthresh，使用拥塞避免算法")])])])]),_._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[_._v("拥塞避免")])]),_._v(" "),s("ul",[s("li",[_._v("拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。")]),_._v(" "),s("li",[_._v("无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:")])]),_._v(" "),s("p",[s("img",{attrs:{src:t(614),alt:""}})]),_._v(" "),s("p",[_._v("其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。")]),_._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[_._v("快速重传")])]),_._v(" "),s("ul",[s("li",[_._v("快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。")]),_._v(" "),s("li",[_._v("由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量")])]),_._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[_._v("快速恢复")])]),_._v(" "),s("ul",[s("li",[_._v("当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。")]),_._v(" "),s("li",[_._v("考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。")])]),_._v(" "),s("p",[s("img",{attrs:{src:t(615),alt:""}})]),_._v(" "),s("h2",{attrs:{id:"_2-tcp的流量控制机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp的流量控制机制"}},[_._v("#")]),_._v(" 2.TCP的流量控制机制")]),_._v(" "),s("p",[_._v("对于发送端和接收端而言，TCP 需要把发送的数据放到"),s("strong",[_._v("发送缓存区")]),_._v(", 将接收的数据放到"),s("strong",[_._v("接收缓存区")]),_._v("。而流量控制要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。")]),_._v(" "),s("p",[_._v("要具体理解流量控制，首先需要了解滑动窗口的概念。")]),_._v(" "),s("p",[_._v("TCP 滑动窗口分为两种: 发送窗口和接收窗口。")]),_._v(" "),s("p",[_._v("发送端的滑动窗口结构如下:")]),_._v(" "),s("p",[s("img",{attrs:{src:t(616),alt:""}})]),_._v(" "),s("p",[_._v("一些重要的概念")]),_._v(" "),s("p",[s("img",{attrs:{src:t(617),alt:""}})]),_._v(" "),s("p",[_._v("发送窗口就是图中被框住的范围。SND 即send, WND 即window, UNA 即unacknowledged, 表示未被确认，NXT 即next, 表示下一个发送的位置。")]),_._v(" "),s("p",[_._v("接收端的窗口结构如下:")]),_._v(" "),s("p",[s("img",{attrs:{src:t(618),alt:""}})]),_._v(" "),s("h3",{attrs:{id:"流量控制过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流量控制过程"}},[_._v("#")]),_._v(" 流量控制过程")]),_._v(" "),s("p",[_._v("首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。")]),_._v(" "),s("p",[_._v("假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。")]),_._v(" "),s("p",[_._v("现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。")]),_._v(" "),s("p",[_._v("注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。")]),_._v(" "),s("p",[_._v("因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。")]),_._v(" "),s("p",[_._v("此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。")]),_._v(" "),s("h2",{attrs:{id:"_3-tcp的三次握手和四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp的三次握手和四次挥手"}},[_._v("#")]),_._v(" 3.TCP的三次握手和四次挥手")]),_._v(" "),s("h3",{attrs:{id:"_1-三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-三次握手"}},[_._v("#")]),_._v(" （1）三次握手")]),_._v(" "),s("p",[s("img",{attrs:{src:t(619),alt:""}})]),_._v(" "),s("p",[_._v("（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。")]),_._v(" "),s("p",[_._v("刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。")]),_._v(" "),s("ul",[s("li",[_._v("第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。")])]),_._v(" "),s("blockquote",[s("p",[_._v("首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。")])]),_._v(" "),s("ul",[s("li",[_._v("第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。")])]),_._v(" "),s("blockquote",[s("p",[_._v("在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y")])]),_._v(" "),s("ul",[s("li",[_._v("第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。")])]),_._v(" "),s("blockquote",[s("p",[_._v("确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。")])]),_._v(" "),s("p",[_._v("那为什么要三次握手呢？两次不行吗？")]),_._v(" "),s("ul",[s("li",[_._v("为了确认双方的接收能力和发送能力都正常")]),_._v(" "),s("li",[_._v("如果是用两次握手，则会出现下面这种情况：")])]),_._v(" "),s("blockquote",[s("p",[_._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")])]),_._v(" "),s("p",[_._v("简单来说就是以下三步：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("第一次握手")]),_._v("： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。")]),_._v(" "),s("li",[s("strong",[_._v("第二次握手")]),_._v("： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。")]),_._v(" "),s("li",[s("strong",[_._v("第三次握手")]),_._v("： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。")])]),_._v(" "),s("p",[_._v("TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。")]),_._v(" "),s("h3",{attrs:{id:"_2-四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-四次挥手"}},[_._v("#")]),_._v(" （2）四次挥手")]),_._v(" "),s("p",[s("img",{attrs:{src:t(620),alt:""}})]),_._v(" "),s("p",[_._v("刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：")]),_._v(" "),s("ul",[s("li",[_._v("第一次挥手： 客户端会发送一个 "),s("strong",[_._v("FIN")]),_._v("报文，报文中会指定一个"),s("strong",[_._v("序列")]),_._v("号。此时客户端处于 "),s("strong",[_._v("FIN_WAIT1")]),_._v(" 状态。")])]),_._v(" "),s("blockquote",[s("p",[_._v("即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")])]),_._v(" "),s("ul",[s("li",[_._v("第二次挥手：服务端收到 FIN 之后，会发送 "),s("strong",[_._v("ACK")]),_._v(" 报文，且把客户端的"),s("strong",[_._v("序列号值 +1")]),_._v("作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。")])]),_._v(" "),s("blockquote",[s("p",[_._v("即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。")])]),_._v(" "),s("ul",[s("li",[_._v("第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 "),s("strong",[_._v("FIN")]),_._v(" 报文，且指定一个"),s("strong",[_._v("序列号")]),_._v("。此时服务端处于 "),s("strong",[_._v("LAST_ACK")]),_._v(" 的状态。")])]),_._v(" "),s("blockquote",[s("p",[_._v("即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。")])]),_._v(" "),s("ul",[s("li",[_._v("第四次挥手：客户端收到 FIN 之后，一样发送一个 "),s("strong",[_._v("ACK")]),_._v(" 报文作为应答，且把服务端的"),s("strong",[_._v("序列号值 +1")]),_._v(" 作为自己 ACK 报文的序列号值，此时客户端处于 "),s("strong",[_._v("TIME_WAIT")]),_._v(" 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 "),s("strong",[_._v("CLOSED")]),_._v(" 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。")])]),_._v(" "),s("blockquote",[s("p",[_._v("为什么需要四次挥手,三次挥手可以吗？当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。")])]),_._v(" "),s("blockquote",[s("p",[_._v("等待2MSL的意义:1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端,1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达")])]),_._v(" "),s("h2",{attrs:{id:"_4-nagle-算法和延迟确认"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-nagle-算法和延迟确认"}},[_._v("#")]),_._v(" 4.Nagle 算法和延迟确认")]),_._v(" "),s("h3",{attrs:{id:"nagle-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nagle-算法"}},[_._v("#")]),_._v(" Nagle 算法")]),_._v(" "),s("p",[_._v("试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。")]),_._v(" "),s("p",[_._v("而避免小包的频繁发送，这就是 Nagle 算法要做的事情。")]),_._v(" "),s("p",[_._v("具体来说，Nagle 算法的规则如下:")]),_._v(" "),s("ul",[s("li",[_._v("当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送")]),_._v(" "),s("li",[_._v("后面发送满足下面条件之一就可以发了:\n"),s("ul",[s("li",[_._v("数据包大小达到最大段大小(Max Segment Size, 即 MSS)")]),_._v(" "),s("li",[_._v("之前所有包的 ACK 都已接收到")])])])]),_._v(" "),s("h3",{attrs:{id:"延迟确认"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延迟确认"}},[_._v("#")]),_._v(" 延迟确认")]),_._v(" "),s("p",[_._v("试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？")]),_._v(" "),s("p",[_._v("延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。")]),_._v(" "),s("p",[_._v("不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:")]),_._v(" "),s("ul",[s("li",[_._v("接收到了大于一个 frame 的报文，且需要调整窗口大小")]),_._v(" "),s("li",[_._v("TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）")]),_._v(" "),s("li",[_._v("发现了乱序包")])]),_._v(" "),s("h3",{attrs:{id:"两者一起使用会怎样"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两者一起使用会怎样"}},[_._v("#")]),_._v(" 两者一起使用会怎样？")]),_._v(" "),s("p",[_._v("前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。")])])}),[],!1,null,null,null);v.default=a.exports}}]);