(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{726:function(t,e,a){"use strict";a.r(e);var v=a(15),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-说一下vue的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-说一下vue的生命周期"}},[t._v("#")]),t._v(" 1.说一下Vue的生命周期")]),t._v(" "),a("p",[t._v("Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("beforeCreate（创建前）")]),t._v("：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。")]),t._v(" "),a("li",[a("strong",[t._v("created（创建后）")]),t._v(" ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。")]),t._v(" "),a("li",[a("strong",[t._v("beforeMount（挂载前）")]),t._v("：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。")]),t._v(" "),a("li",[a("strong",[t._v("mounted（挂载后）")]),t._v("：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。")]),t._v(" "),a("li",[a("strong",[t._v("beforeUpdate（更新前）")]),t._v("：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。")]),t._v(" "),a("li",[a("strong",[t._v("updated（更新后）")]),t._v(" ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。")]),t._v(" "),a("li",[a("strong",[t._v("beforeDestroy（销毁前）")]),t._v("：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。")]),t._v(" "),a("li",[a("strong",[t._v("destroyed（销毁后）")]),t._v("：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。")])]),t._v(" "),a("p",[t._v("另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。")]),t._v(" "),a("h2",{attrs:{id:"_2-created和mounted的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-created和mounted的区别"}},[t._v("#")]),t._v(" 2.created和mounted的区别")]),t._v(" "),a("ul",[a("li",[t._v("created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。")]),t._v(" "),a("li",[t._v("mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。")])]),t._v(" "),a("h2",{attrs:{id:"_3-一般在哪个生命周期请求异步数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-一般在哪个生命周期请求异步数据"}},[t._v("#")]),t._v(" 3.一般在哪个生命周期请求异步数据")]),t._v(" "),a("p",[t._v("我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。​")]),t._v(" "),a("p",[t._v("推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),t._v(" "),a("ul",[a("li",[t._v("能更快获取到服务端数据，减少页面加载时间，用户体验更好；")]),t._v(" "),a("li",[t._v("SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);