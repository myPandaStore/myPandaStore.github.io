(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{671:function(t,s,a){"use strict";a.r(s);var r=a(15),_=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[t._v("#")]),t._v(" 1.概述：")]),t._v(" "),a("p",[t._v("js的垃圾回收机制是为了防止内存泄漏（已经不需要的某一块内存还一直存在着），垃圾回收机制就是不停歇的寻找这些不再使用的变量，并且释放掉它所指向的内存。\n在JS中，JS的执行环境会负责管理代码执行过程中使用的内存。")]),t._v(" "),a("h2",{attrs:{id:"_2-变量的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-变量的生命周期"}},[t._v("#")]),t._v(" 2.变量的生命周期")]),t._v(" "),a("p",[t._v("当一个变量的生命周期结束之后，它所指向的内存就会被释放。js有两种变量，局部变量和全局变量，局部变量是在他当前的函数中产生作用，当该函数结束之后，该变量内存会被释放，全局变量的话会一直存在，直到浏览器关闭为止。")]),t._v(" "),a("h2",{attrs:{id:"_3-js垃圾回收方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-js垃圾回收方式"}},[t._v("#")]),t._v(" 3.js垃圾回收方式")]),t._v(" "),a("p",[t._v("1."),a("strong",[t._v("标记清除")]),t._v("：大部分浏览器使用这种垃圾回收，当变量进入执行环境(声明变量）的时候，垃圾回收器将该变量进行了标记，当该变量离开环境的时候，将其再度标记，随之进行删除。")]),t._v(" "),a("p",[t._v("2."),a("strong",[t._v("引用计数")]),t._v("：这种方式常常会引起内存的泄露，主要存在于低版本的浏览器。它的机制就是跟踪某一个值得引用次数，当声明一个变量并且将一个引用类型赋值给变量得时候引用次数加1，当这个变量指向其他一个时引用次数减1，当为0时出发回收机制进行回收。")])])}),[],!1,null,null,null);s.default=_.exports}}]);