(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{690:function(_,v,t){"use strict";t.r(v);var e=t(15),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-什么是-xss-攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是-xss-攻击"}},[_._v("#")]),_._v(" 1. 什么是 XSS 攻击？")]),_._v(" "),t("p",[_._v("(1) 概念")]),_._v(" "),t("p",[_._v("XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。"),t("br"),_._v("\nXSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。"),t("br"),_._v("\n攻击者可以通过这种攻击方式可以进行以下操作：")]),_._v(" "),t("ul",[t("li",[_._v("获取页面的数据，如DOM、cookie、localStorage；")]),_._v(" "),t("li",[_._v("DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；")]),_._v(" "),t("li",[_._v("破坏页面结构；")]),_._v(" "),t("li",[_._v("流量劫持（将链接指向某网站）")])]),_._v(" "),t("p",[_._v("(2) XSS攻击类型")]),_._v(" "),t("p",[_._v("XSS 可以分为存储型、反射型和 文档 型：")]),_._v(" "),t("ul",[t("li",[_._v("存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。")]),_._v(" "),t("li",[_._v("反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。")]),_._v(" "),t("li",[_._v("文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。")])]),_._v(" "),t("h2",{attrs:{id:"_2-如何防御-xss-攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何防御-xss-攻击"}},[_._v("#")]),_._v(" 2.如何防御 XSS 攻击？")]),_._v(" "),t("ol",[t("li",[_._v("不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。"),t("br")]),_._v(" "),t("li",[_._v("使用 CSP(内容安全策略) ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。")])]),_._v(" "),t("blockquote",[t("p",[_._v("1.CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现"),t("br"),_._v("\n2.通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式")])]),_._v(" "),t("p",[_._v("3.对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。")]),_._v(" "),t("h2",{attrs:{id:"_3-什么是-csrf-攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么是-csrf-攻击"}},[_._v("#")]),_._v(" 3.什么是 CSRF 攻击？")]),_._v(" "),t("p",[_._v("(1) 概念")]),_._v(" "),t("p",[_._v("CSRF 攻击指的是"),t("strong",[_._v("跨站请求伪造攻击")]),_._v("，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。")]),_._v(" "),t("p",[_._v("CSRF 攻击的本质是"),t("strong",[_._v("利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充")]),_._v("。")]),_._v(" "),t("p",[_._v("(2) 攻击类型")]),_._v(" "),t("ul",[t("li",[_._v("GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。")]),_._v(" "),t("li",[_._v("POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。")]),_._v(" "),t("li",[_._v("链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。")])]),_._v(" "),t("h2",{attrs:{id:"_4-如何防御-csrf-攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何防御-csrf-攻击"}},[_._v("#")]),_._v(" 4. 如何防御 CSRF 攻击？")]),_._v(" "),t("p",[_._v("防御CSRF，最重要的是确保用户身份的验证、使用TLS、防止重定向、使用Same-Origin Policy、使用令牌和保持页面和请求同步。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("进行同源检测")]),_._v("，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）")]),_._v(" "),t("li",[t("strong",[_._v("使用 CSRF Token 进行验证")]),_._v("，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。")]),_._v(" "),t("li",[t("strong",[_._v("对 Cookie 进行双重验证")]),_._v("，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。")]),_._v(" "),t("li",[t("strong",[_._v("在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用")]),_._v("，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。")])]),_._v(" "),t("h2",{attrs:{id:"_5-什么是中间人攻击-如何防范中间人攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-什么是中间人攻击-如何防范中间人攻击"}},[_._v("#")]),_._v(" 5.什么是中间人攻击？如何防范中间人攻击？")]),_._v(" "),t("p",[_._v("中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。")]),_._v(" "),t("p",[_._v("过程如下:")]),_._v(" "),t("ul",[t("li",[_._v("客户端发送请求到服务端，请求被中间⼈截获")]),_._v(" "),t("li",[_._v("服务器向客户端发送公钥")]),_._v(" "),t("li",[_._v("中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个伪造的公钥，发给客户端")]),_._v(" "),t("li",[_._v("客户端收到伪造的公钥后，⽣成加密hash值发给服务器")]),_._v(" "),t("li",[_._v("中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器")]),_._v(" "),t("li",[_._v("服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端")])]),_._v(" "),t("h2",{attrs:{id:"_6-网络劫持有哪几种-如何防范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-网络劫持有哪几种-如何防范"}},[_._v("#")]),_._v(" 6.网络劫持有哪几种，如何防范？")]),_._v(" "),t("p",[_._v("(1) DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)")]),_._v(" "),t("ul",[t("li",[_._v("DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器")]),_._v(" "),t("li",[_._v("302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容")])]),_._v(" "),t("p",[_._v("（2） HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)")]),_._v(" "),t("p",[_._v("DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。")])])}),[],!1,null,null,null);v.default=o.exports}}]);