(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{624:function(t,e,s){t.exports=s.p+"assets/img/001.eb0761c8.png"},625:function(t,e,s){t.exports=s.p+"assets/img/002.22a7b0a1.png"},626:function(t,e,s){t.exports=s.p+"assets/img/003.943e0d33.png"},627:function(t,e,s){t.exports=s.p+"assets/img/004.df09122e.png"},724:function(t,e,s){"use strict";s.r(e);var a=s(15),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-vue的基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue的基本原理"}},[t._v("#")]),t._v(" 1.Vue的基本原理")]),t._v(" "),a("p",[t._v("当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(624),alt:""}})]),t._v(" "),a("h2",{attrs:{id:"_2-双向数据绑定的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-双向数据绑定的原理"}},[t._v("#")]),t._v(" 2.双向数据绑定的原理")]),t._v(" "),a("p",[t._v("Vue.js 是采用"),a("strong",[t._v("数据劫持")]),t._v("结合"),a("strong",[t._v("发布者-订阅者模式")]),t._v("的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：")]),t._v(" "),a("ul",[a("li",[t._v("需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化")]),t._v(" "),a("li",[t._v("compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),t._v(" "),a("li",[t._v("Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")]),t._v(" "),a("li",[t._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(625),alt:""}})]),t._v(" "),a("h2",{attrs:{id:"_3-使用-object-defineproperty-来进行数据劫持有什么缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-object-defineproperty-来进行数据劫持有什么缺点"}},[t._v("#")]),t._v(" 3.使用 Object.defineProperty() 来进行数据劫持有什么缺点？")]),t._v(" "),a("p",[t._v("在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。")]),t._v(" "),a("p",[t._v("在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。")]),t._v(" "),a("h2",{attrs:{id:"_4-mvvm、mvc、mvp的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvvm、mvc、mvp的区别"}},[t._v("#")]),t._v(" 4.MVVM、MVC、MVP的区别")]),t._v(" "),a("p",[t._v("MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。")]),t._v(" "),a("p",[t._v("在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。")]),t._v(" "),a("p",[t._v("(1) MVC")]),t._v(" "),a("p",[t._v("MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(626),alt:""}})]),t._v(" "),a("p",[t._v("(2) MVVM")]),t._v(" "),a("p",[t._v("MVVM 分为 Model、View、ViewModel：MVVM 分为 Model、View、ViewModel：")]),t._v(" "),a("ul",[a("li",[t._v("Model代表数据模型，数据和业务逻辑都在Model层中定义；")]),t._v(" "),a("li",[t._v("View代表UI视图，负责数据的展示；")]),t._v(" "),a("li",[t._v("ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；")])]),t._v(" "),a("p",[t._v("Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。")]),t._v(" "),a("p",[t._v("这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(627),alt:""}})]),t._v(" "),a("p",[t._v("(3) MVP")]),t._v(" "),a("p",[t._v("MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。")]),t._v(" "),a("h2",{attrs:{id:"_5-computed-和-watch-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-computed-和-watch-的区别"}},[t._v("#")]),t._v(" 5.Computed 和 Watch 的区别")]),t._v(" "),a("p",[a("strong",[t._v("Computed：")])]),t._v(" "),a("ul",[a("li",[t._v("它"),a("strong",[t._v("支持缓存")]),t._v("，只有依赖的数据发生了变化，才会重新计算")]),t._v(" "),a("li",[a("strong",[t._v("不支持异步")]),t._v("，当Computed中有异步操作时，无法监听数据的变化")]),t._v(" "),a("li",[t._v("如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。")])]),t._v(" "),a("p",[a("strong",[t._v("Watch：")])]),t._v(" "),a("ul",[a("li",[t._v("它不支持缓存，数据变化时，它就会触发相应的操作")]),t._v(" "),a("li",[t._v("支持异步监听")]),t._v(" "),a("li",[t._v("监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值")]),t._v(" "),a("li",[t._v("监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\n"),a("ul",[a("li",[t._v("immediate：组件加载立即触发回调函数")]),t._v(" "),a("li",[t._v("deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。")])])])]),t._v(" "),a("p",[t._v("当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。")]),t._v(" "),a("p",[a("strong",[t._v("总结：")])]),t._v(" "),a("ul",[a("li",[t._v("computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。")]),t._v(" "),a("li",[t._v("watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。")])]),t._v(" "),a("h2",{attrs:{id:"_6-slot是什么-有什么作用-原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-slot是什么-有什么作用-原理是什么"}},[t._v("#")]),t._v(" 6.slot是什么？有什么作用？原理是什么？")]),t._v(" "),a("p",[t._v("slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。")]),t._v(" "),a("ul",[a("li",[t._v("默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。")]),t._v(" "),a("li",[t._v("具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。")]),t._v(" "),a("li",[t._v("作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。")])]),t._v(" "),a("p",[t._v("实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。")]),t._v(" "),a("h2",{attrs:{id:"_7-过滤器的作用-如何实现一个过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-过滤器的作用-如何实现一个过滤器"}},[t._v("#")]),t._v(" 7.过滤器的作用，如何实现一个过滤器")]),t._v(" "),a("p",[t._v("根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。")]),t._v(" "),a("p",[a("strong",[t._v("使用场景：")])]),t._v(" "),a("ul",[a("li",[t._v("需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。")]),t._v(" "),a("li",[t._v("比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。")])]),t._v(" "),a("p",[t._v("过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 "+t._s()+" 和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。")]),t._v(" "),a("p",[t._v("例如，在显示金额，给商品价格添加单位：")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("商品价格："),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("price "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" filterPrice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("filters")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("filterPrice")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("price")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" price "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'￥'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'--'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("h2",{attrs:{id:"_8-如何保存页面的当前的状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-如何保存页面的当前的状态"}},[t._v("#")]),t._v(" 8.如何保存页面的当前的状态")]),t._v(" "),a("p",[t._v("既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：")]),t._v(" "),a("ul",[a("li",[t._v("前组件会被卸载")]),t._v(" "),a("li",[t._v("前组件不会被卸载")])]),t._v(" "),a("p",[t._v("那么可以按照这两种情况分别得到以下方法：")]),t._v(" "),a("p",[a("strong",[t._v("组件会被卸载：")])]),t._v(" "),a("p",[t._v("(1) 将状态存储在LocalStorage / SessionStorage")]),t._v(" "),a("p",[t._v("只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。")]),t._v(" "),a("p",[t._v("比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。")]),t._v(" "),a("p",[a("strong",[t._v("优点：")])]),t._v(" "),a("ul",[a("li",[t._v("兼容性好，不需要额外库或工具。")]),t._v(" "),a("li",[t._v("简单快捷，基本可以满足大部分需求。")])]),t._v(" "),a("p",[a("strong",[t._v("缺点：")])]),t._v(" "),a("ul",[a("li",[t._v("状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）")]),t._v(" "),a("li",[t._v("如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象")])]),t._v(" "),a("p",[t._v("(2) 路由传值")]),t._v(" "),a("p",[t._v("通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。")]),t._v(" "),a("p",[t._v("在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。")]),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ul",[a("li",[t._v("简单快捷，不会污染 LocalStorage / SessionStorage。")]),t._v(" "),a("li",[t._v("可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[t._v("如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。")])]),t._v(" "),a("p",[a("strong",[t._v("组件不会被卸载：")])]),t._v(" "),a("p",[t._v("(1) 单页面渲染")]),t._v(" "),a("p",[t._v("要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。")]),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ul",[a("li",[t._v("代码量少")]),t._v(" "),a("li",[t._v("不需要考虑状态传递过程中的错误")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[t._v("增加 A 组件维护成本")]),t._v(" "),a("li",[t._v("需要传入额外的 prop 到 B 组件")]),t._v(" "),a("li",[t._v("无法利用路由定位页面")])]),t._v(" "),a("p",[t._v("除此之外，在Vue中，还可以使用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("keep"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("router"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view v"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"$route.meta.keepAlive"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("router"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("kepp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("alive"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("router.js")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("component")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'../src/views/xxx.vue'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("meta")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("keepAlive")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要被缓存")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("h2",{attrs:{id:"_9-常见的事件修饰符及其作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-常见的事件修饰符及其作用"}},[t._v("#")]),t._v(" 9.常见的事件修饰符及其作用")]),t._v(" "),a("ul",[a("li",[t._v(".stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；")]),t._v(" "),a("li",[t._v(".prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；")]),t._v(" "),a("li",[t._v(".capture ：与事件冒泡的方向相反，事件捕获由外到内；")]),t._v(" "),a("li",[t._v(".self ：只会触发自己范围内的事件，不包含子元素；")]),t._v(" "),a("li",[t._v(".once ：只会触发一次。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);