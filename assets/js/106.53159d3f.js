(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{732:function(e,_,v){"use strict";v.r(_);var t=v(15),a=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_1-对虚拟dom的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-对虚拟dom的理解"}},[e._v("#")]),e._v(" 1.对虚拟DOM的理解？")]),e._v(" "),v("p",[e._v("从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。")]),e._v(" "),v("h2",{attrs:{id:"_2-虚拟dom的解析过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-虚拟dom的解析过程"}},[e._v("#")]),e._v(" 2.虚拟DOM的解析过程")]),e._v(" "),v("ul",[v("li",[e._v("首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。")]),e._v(" "),v("li",[e._v("当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异")]),e._v(" "),v("li",[e._v("最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了")])]),e._v(" "),v("h2",{attrs:{id:"_3-为什么要用虚拟dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么要用虚拟dom"}},[e._v("#")]),e._v(" 3.为什么要用虚拟DOM")]),e._v(" "),v("p",[e._v("(1) 保证性能下限")]),e._v(" "),v("p",[e._v("在不进行手动优化的情况下，提供过得去的性能.看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶")]),e._v(" "),v("ul",[v("li",[e._v("真实DOM∶ 生成HTML字符串＋重建所有的DOM元素")]),e._v(" "),v("li",[e._v("虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新")])]),e._v(" "),v("p",[e._v("(2) 跨平台")]),e._v(" "),v("p",[e._v("Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。")]),e._v(" "),v("h2",{attrs:{id:"_4-虚拟dom真的比真实dom性能好吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-虚拟dom真的比真实dom性能好吗"}},[e._v("#")]),e._v(" 4.虚拟DOM真的比真实DOM性能好吗")]),e._v(" "),v("ul",[v("li",[e._v("首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。")]),e._v(" "),v("li",[e._v("正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。")])]),e._v(" "),v("h2",{attrs:{id:"_5-diff算法的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-diff算法的原理"}},[e._v("#")]),e._v(" 5.DIFF算法的原理")]),e._v(" "),v("p",[e._v("vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？")]),e._v(" "),v("p",[e._v("参考答案：\n简单来说，diff 算法有以下过程")]),e._v(" "),v("p",[e._v("同级比较，再比较子节点\n先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)\n比较都有子节点的情况(核心 diff)\n递归比较子节点")]),e._v(" "),v("p",[e._v("正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从O(n^3) -> O(n)，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。")]),e._v(" "),v("p",[e._v("Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。\nVue3.x 借鉴了 ivi 算法和 inferno 算法\n在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。")]),e._v(" "),v("p",[e._v("作者：法医\n链接：https://juejin.cn/post/7208005892313579576\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")]),e._v(" "),v("h2",{attrs:{id:"_6-vue中key的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue中key的作用"}},[e._v("#")]),e._v(" 6.Vue中key的作用")]),e._v(" "),v("ul",[v("li",[e._v("第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会"),v("strong",[e._v("复用已有元素")]),e._v("而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。")]),e._v(" "),v("li",[e._v("第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。")])]),e._v(" "),v("p",[e._v("key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速")]),e._v(" "),v("ul",[v("li",[e._v("更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。")]),e._v(" "),v("li",[e._v("更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快")])]),e._v(" "),v("h2",{attrs:{id:"_7-为什么不建议用index作为key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么不建议用index作为key"}},[e._v("#")]),e._v(" 7.为什么不建议用index作为key?")]),e._v(" "),v("p",[e._v("使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。")])])}),[],!1,null,null,null);_.default=a.exports}}]);