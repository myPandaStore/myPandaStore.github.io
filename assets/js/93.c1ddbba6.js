(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{718:function(t,_,e){"use strict";e.r(_);var s=e(15),r=Object(s.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-模块化概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-模块化概念"}},[t._v("#")]),t._v(" 1.模块化概念")]),t._v(" "),e("ul",[e("li",[t._v("模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。")]),t._v(" "),e("li",[t._v("模块化可提高代码的复用性和可维护性，实现按需加载。")]),t._v(" "),e("li",[t._v("模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。")])]),t._v(" "),e("h2",{attrs:{id:"_2-node-js-中模块的分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-node-js-中模块的分类"}},[t._v("#")]),t._v(" 2.Node.js 中模块的分类")]),t._v(" "),e("ul",[e("li",[t._v("内置模块")]),t._v(" "),e("li",[t._v("自定义模块")]),t._v(" "),e("li",[t._v("第三方模块")])]),t._v(" "),e("h2",{attrs:{id:"_3-node-js-中的模块作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-node-js-中的模块作用域"}},[t._v("#")]),t._v(" 3.Node.js 中的模块作用域")]),t._v(" "),e("ul",[e("li",[t._v("和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域")]),t._v(" "),e("li",[t._v("防止全局变量污染")])]),t._v(" "),e("h2",{attrs:{id:"_4-模块作用域的成员"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-模块作用域的成员"}},[t._v("#")]),t._v(" 4.模块作用域的成员")]),t._v(" "),e("ul",[e("li",[t._v("自定义模块中都有一个 module 对象，存储了和当前模块有关的信息")]),t._v(" "),e("li",[t._v("在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。")]),t._v(" "),e("li",[t._v("默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准。")])]),t._v(" "),e("h2",{attrs:{id:"_5-commonjs-模块化规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-commonjs-模块化规范"}},[t._v("#")]),t._v(" 5.CommonJS 模块化规范")]),t._v(" "),e("ul",[e("li",[t._v("每个模块内部，module 变量代表当前模块")]),t._v(" "),e("li",[t._v("module 变量是一个对象，module.exports 是对外的接口")]),t._v(" "),e("li",[t._v("加载某个模块即加载该模块的 module.exports 属性")])]),t._v(" "),e("h2",{attrs:{id:"_6-模块加载机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-模块加载机制"}},[t._v("#")]),t._v(" 6.模块加载机制")]),t._v(" "),e("p",[t._v("模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。")]),t._v(" "),e("p",[t._v("内置模块加载内置模块加载优先级最高。")]),t._v(" "),e("p",[t._v("自定义模块加载")]),t._v(" "),e("p",[t._v("第三方模块加载")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_41682025/article/details/111242903",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端工程化"),e("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);